List<Bson> aggregationPipeline = Arrays.asList(
    // Match documents from Collection 1 based on mapDefId, masterId, and presence of delta.input
    Aggregates.match(Filters.and(
        Filters.eq("mapDefId", mapDefId), // Use the mapDefId for filtering
        Filters.eq("masterId", masterId), // Use the masterId for filtering
        Filters.exists("delta.input") // Ensure delta.input is present
    )),
    
    // Add fields for selection attributes (attributes to be filtered based on selection criteria)
    Aggregates.addFields(new Field<>("selectionAttributes", new Document("input", new Document("$filter", 
        new Document("input", "$delta.input")
            .append("as", "item")
            .append("cond", new Document("$in", Arrays.asList(
                "$$item.name", selectionAttributes)))))), 
    
    // Project to include necessary fields and remove unnecessary ones
    Aggregates.project(Projections.fields(
        Projections.include("seq", "mapDefId", "masterId", "selectionAttributes", "snapshot.input", "delta.input")
    )),
    
    // Lookup documents from Collection 2 based on seq field
    Aggregates.lookup("collection2", "seq", "seq", "joined_docs"),
    
    // Unwind the joined documents from Collection 2
    Aggregates.unwind("$joined_docs", true),
    
    // Group by selection attributes and collect distinct grouping attribute values
    Aggregates.group(new Field<>("groupKey", 
        new Document("selectionAttributes", "$selectionAttributes")
            .append("groupingAttributes", "$groupingAttributes")),
        Accumulators.addToSet("groupingAttributesValues", "$joined_docs.input")),
    
    // Filter group results where groupingAttributesValues have more than 3 distinct values
    Aggregates.match(Filters.gt(new Document("groupingAttributesValues", new Document("$size", 3))))
);
