List<Bson> aggregationPipeline = Arrays.asList(
    // Match documents from Collection 1 based on mapDefId, masterId, and presence of delta.input
    Aggregates.match(Filters.and(
        Filters.eq("mapDefId", mapDefId), // Use mapDefId for filtering in Collection 1
        Filters.eq("masterId", masterId), // Use masterId for filtering
        Filters.exists("delta.input") // Ensure delta.input is present
    )),
    
    // Add fields for selection attributes using $filter operator based on the provided selectionAttributes
    Aggregates.addFields(
        new Field<>("selectionAttributes", 
            new Document("$filter", 
                new Document("input", "$delta.input")
                    .append("as", "item")
                    .append("cond", new Document("$in", Arrays.asList(
                        "$$item.name", selectionAttributes)) // Dynamically match based on selectionAttributes
                    )
                )
            )
        )
    ),
    
    // Project to include necessary fields
    Aggregates.project(Projections.fields(
        Projections.include("seq", "mapDefId", "masterId", "selectionAttributes", "snapshot.input", "delta.input")
    )),
    
    // Lookup documents from Collection 2 based on both seq and mapDefId using the let operator
    Aggregates.lookup(
        "collection2",  // Collection 2
        Arrays.asList(  // Using the let operator to define the local fields
            new Document("seq", "$seq"),
            new Document("mapDefId", "$mapDefId")
        ),
        Arrays.asList(  // Matching these fields with the corresponding foreign fields in Collection 2
            new Document("seq", "$$seq"), // Reference the let variable $$seq
            new Document("mapDefId", "$$mapDefId") // Reference the let variable $$mapDefId
        ),
        "joined_docs"  // The name of the field to store the joined documents
    ),
    
    // Unwind the joined documents from Collection 2
    Aggregates.unwind("$joined_docs", new UnwindOptions().preserveNullAndEmptyArrays(true)),
    
    // Group by selection attributes and collect distinct grouping attribute values
    Aggregates.group("_id", 
        Accumulators.addToSet("selectionAttributes", "$selectionAttributes"),
        Accumulators.addToSet("groupingAttributesValues", "$joined_docs.input")
    ),
    
    // Match where groupingAttributesValues have more than 3 distinct values
    Aggregates.match(Filters.expr(
        new Document("$gt", Arrays.asList(
            new Document("$size", "$groupingAttributesValues"), 3
        ))
    ))
);
