db.collectionB.aggregate([
  // Step 1: Perform the lookup and cast mapDefId in collection A to a string
  {
    $lookup: {
      from: "collectionA",
      let: { mapDefIdStr: "$context.mapDefId" }, // Cast collectionB.mapDefId to string
      pipeline: [
        {
          $addFields: { mapDefIdStr: { $toString: "$mapDefId" } } // Cast collectionA.mapDefId to string
        },
        {
          $match: {
            $expr: { $eq: ["$$mapDefIdStr", "$mapDefIdStr"] } // Match on casted mapDefId
          }
        }
      ],
      as: "matched_docs"
    }
  },
  {
    $unwind: "$matched_docs" // Flatten the matched_docs array
  },
  // Step 2: Filter based on ruleDefId and _id
  {
    $match: {
      $expr: {
        $and: [
          { $ne: ["$context.ruleDefId", { $toString: "$matched_docs._id" }] }, // Compare ruleDefId as string with _id
          { $eq: ["$context.mapDefId", "$matched_docs.mapDefIdStr"] }         // mapDefId matches
        ]
      }
    }
  },
  // Step 3: Optionally project fields
  {
    $project: {
      _id: 1,
      "context.ruleDefId": 1,
      "context.mapDefId": 1
    }
  }
]);
