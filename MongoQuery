import com.mongodb.client.model.*;
import org.bson.Document;
import org.bson.conversions.Bson;

import java.util.*;

public class MongoAggregation {
    public static void main(String[] args) {
        // Provided dynamic values
        String mapDefId = "99";  
        String masterId = "12";  
        List<String> selectionAttributes = Arrays.asList("cdsid", "mpsid");  
        List<String> groupingAttributes = Arrays.asList("line1", "line2");  

        // Step 1: Match documents based on mapDefId and masterId in Collection 1
        Bson matchStage = Aggregates.match(Filters.and(
            Filters.eq("mapDefId", mapDefId),
            Filters.eq("masterId", masterId)
        ));

        // Step 2: Unwind delta.input and snapshot.input to flatten attributes
        Bson unwindDelta = Aggregates.unwind("$delta.input", true);
        Bson unwindSnapshot = Aggregates.unwind("$snapshot.input", true);

        // Step 3: Prepare dynamic selectionFieldUpdates for attributes
        List<Bson> selectionFieldUpdates = new ArrayList<>();

         // Step 3: Prepare dynamic selectionFieldUpdates for attributes
        // Step 3: Prepare dynamic selectionFieldUpdates for attributes using an array
        Field<?>[] selectionFieldUpdates = new Field<?>[selectionAttributes.size()];

        // Iterate over each selection attribute and build the update operations
        for (int i = 0; i < selectionAttributes.size(); i++) {
            String attr = selectionAttributes.get(i);
            
            Document filterDelta = new Document("$filter", new Document()
                    .append("input", "$delta.input")
                    .append("as", "item")
                    .append("cond", new Document("$eq", Arrays.asList("$$item.name", attr))));

            Document filterSnapshot = new Document("$filter", new Document()
                    .append("input", "$snapshot.input")
                    .append("as", "item")
                    .append("cond", new Document("$eq", Arrays.asList("$$item.name", attr))));

            // Construct the update operation with $ifNull
            Document setFieldUpdate = new Document("$ifNull", Arrays.asList(
                    new Document("$arrayElemAt", Arrays.asList(filterDelta, 0)),
                    new Document("$arrayElemAt", Arrays.asList(filterSnapshot, 0))
            ));

            // Add to the array of selectionFieldUpdates
            selectionFieldUpdates[i] = new Field<>(attr, setFieldUpdate);
        }

            // Add the field update to the selectionFieldUpdates list // 37
            selectionFieldUpdates.add(Updates.addFields(new Field<>(attr, setFieldUpdate)));  // 38
        }

        // Step 5: Lookup Collection 2 using seq and mapDefId
        Bson lookupStage = Aggregates.lookup(
            "collection2",  // Name of the second collection
            Arrays.asList("seq", "mapDefId"),  // Local fields from Collection 1
            Arrays.asList("seq", "mapDefId"),  // Foreign fields from Collection 2
            "joined_docs"    // Name of the new field to store the joined documents
        );

        // Step 6: Handle missing lookup results (if empty, fallback to Collection 1 only)
        Bson setFallback = Aggregates.addFields(
            new Field<>("joined_docs", new Document("$ifNull", Arrays.asList("$joined_docs", Collections.emptyList())))
        );

        // Step 7: Unwind the joined_docs, keeping null values (optional)
        Bson unwindJoinedDocs = Aggregates.unwind("$joined_docs", true);

        // Step 8: Match the documents based on the lookup result
        Bson matchLookupSuccess = Aggregates.match(new Document("$or", Arrays.asList(
            new Document("joined_docs", new Document("$ne", Collections.emptyList())),  // Lookup succeeded
            new Document("joined_docs", new Document("$exists", false))  // Fallback to Collection 1
        )));

        // Step 9: Group by dynamically provided grouping attributes
        Document groupFields = new Document();
        for (String attr : groupingAttributes) {
            groupFields.append(attr, "$" + attr);
        }

        Bson groupStage = Aggregates.group(
            groupFields,
            Accumulators.addToSet("groupingAttributesValues", "$$ROOT")
        );

        // Step 10: Filter groups where the size of distinct line values > 3
        Bson matchSizeFilter = Aggregates.match(Filters.expr(new Document("$gt", Arrays.asList(
            new Document("$size", "$groupingAttributesValues"), 3
        ))));

        // Step 11: Build the full aggregation pipeline
        List<Bson> aggregationPipeline = Arrays.asList(
            matchStage,           // Match the base documents
            unwindDelta,          // Unwind the delta.input field
            unwindSnapshot,       // Unwind the snapshot.input field
            addSelectionFields,    // Add selection fields dynamically
            lookupStage,           // Lookup into Collection 2
            setFallback,           // Ensure joined_docs field is not null
            unwindJoinedDocs,      // Unwind the joined docs from Collection 2
            matchLookupSuccess,    // Match successful lookup or fallback
            groupStage,            // Group the documents by dynamic attributes
            matchSizeFilter        // Filter groups based on size condition
        );

        // The aggregation pipeline is ready to be executed
        System.out.println(aggregationPipeline);
    }
}
