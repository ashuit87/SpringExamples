import com.mongodb.client.MongoCollection;
import com.mongodb.client.model.Aggregates;
import com.mongodb.client.model.Filters;
import com.mongodb.client.model.UnwindOptions;
import org.bson.Document;
import org.bson.conversions.Bson;

import java.util.Arrays;
import java.util.List;

MongoCollection<Document> collection1 = database.getCollection("collection1"); // First collection
MongoCollection<Document> collection2 = database.getCollection("collection2"); // Second collection

// Dynamic selection attributes and grouping attributes
List<String> selectionAttributes = Arrays.asList("cdsid", "mpsid"); // Example dynamic selection attributes
List<String> groupingAttributes = Arrays.asList("line1", "line2"); // Example dynamic grouping attributes

// Define mapDefId and masterId for filtering
String mapDefId = "99"; // Replace with your dynamic mapDefId
String masterId = "12"; // Replace with your dynamic masterId

// Dynamically create the group-by stage for selection attributes
Document groupFields = new Document();
for (String selectionAttribute : selectionAttributes) {
    groupFields.append(selectionAttribute, 
        new Document("$first", new Document("$cond", Arrays.asList(
            new Document("$eq", Arrays.asList("$delta.input.name", selectionAttribute)), 
            "$delta.input.value", null))));
}

// Dynamically collect distinct group attribute values (previously "lineValues")
Document groupAttributeValues = new Document("groupAttributeValues", 
    new Document("$push", new Document("$cond", Arrays.asList(
        new Document("$in", Arrays.asList("$delta.input.name", groupingAttributes)),
        new Document("$split", Arrays.asList("$delta.input.value", ";")),
        Arrays.asList())))));

// Add the group attribute values collection to the group fields
groupFields.append("groupAttributeValues", groupAttributeValues);

// Aggregation pipeline for both collections with $lookup for the join
List<Bson> pipeline = Arrays.asList(
    // Match documents based on mapDefId and masterId in the first collection (no seq filter here)
    Aggregates.match(Filters.and(
        Filters.eq("mapDefId", mapDefId),
        Filters.eq("masterId", masterId)  // Only in Collection 1
    )),
    
    // Perform $lookup to join the second collection based on seq field
    Aggregates.lookup(
        "collection2", // Name of the second collection
        "seq", // Field from the first collection (to match with Collection 2)
        "seq", // Field from the second collection (to match with Collection 1)
        "joined_docs" // Alias for the joined data
    ),
    
    // Unwind the joined documents from the second collection, preserve nulls if needed
    Aggregates.unwind("$joined_docs", new UnwindOptions().preserveNullAndEmptyArrays(true)),
    
    // Match the selection attributes (cdsid, mpsid) in both collections
    Aggregates.match(Filters.in("delta.input.name", selectionAttributes)),
    
    // Group by selection attributes dynamically and collect distinct group attribute values
    Aggregates.group(groupFields),
    
    // Project to get the union of grouping attributes (line1, line2 values), ensuring uniqueness
    Aggregates.project(new Document("groupAttributeValues", new Document("$reduce", new Document("input", "$groupAttributeValues")
        .append("initialValue", Arrays.asList())
        .append("in", new Document("$setUnion", Arrays.asList("$$value", "$$this")))))),

    // Match only those records where the number of distinct groupAttributeValues > 3
    Aggregates.match(Filters.expr(new Document("$gt", Arrays.asList(
        new Document("$size", "$groupAttributeValues"), 3))))
);

// Execute the aggregation query
AggregateIterable<Document> result = collection1.aggregate(pipeline);

// Iterate over the result and process documents
for (Document doc : result) {
    System.out.println(doc.toJson());
}
