import com.mongodb.client.MongoCollection;
import com.mongodb.client.model.Aggregates;
import com.mongodb.client.model.Filters;
import org.bson.Document;
import org.bson.conversions.Bson;

import java.util.Arrays;
import java.util.List;

MongoCollection<Document> collection1 = database.getCollection("collection1"); // First collection
MongoCollection<Document> collection2 = database.getCollection("collection2"); // Second collection

// Dynamic selection attributes and grouping attributes
List<String> selectionAttributes = Arrays.asList("cdsid", "mpsid");
List<String> groupingAttributes = Arrays.asList("line1", "line2");

// Define seq value, mapDefId, and masterId for matching
String seqValue = "31923"; // Replace with your dynamic seq value
String mapDefId = "99"; // Replace with your dynamic mapDefId
String masterId = "12"; // Replace with your dynamic masterId

// Aggregation pipeline for both collections with $lookup for the join
List<Bson> pipeline = Arrays.asList(
    // Match documents based on seq, mapDefId, and masterId in the first collection
    Aggregates.match(Filters.and(
        Filters.eq("seq", seqValue),
        Filters.eq("mapDefId", mapDefId),
        Filters.eq("masterId", masterId)  // Only in Collection 1
    )),
    
    // Perform $lookup to join the second collection based on seq field
    Aggregates.lookup(
        "collection2", // Name of the second collection
        "seq", // Field from the first collection
        "seq", // Field from the second collection
        "joined_docs" // Alias for the joined data
    ),
    
    // Unwind the joined documents from the second collection
    Aggregates.unwind("$joined_docs", true),
    
    // Match the selection attributes (cdsid, mpsid) in both collections
    Aggregates.match(Filters.in("delta.input.name", selectionAttributes)),
    
    // Group by selection attributes (cdsid, mpsid) and collect distinct line values
    Aggregates.group(
        new Document("cdsid", new Document("$first", 
            new Document("$cond", Arrays.asList(
                new Document("$eq", Arrays.asList("$delta.input.name", "cdsid")), 
                "$delta.input.value", null))))
        ).append("mpsid", new Document("$first", 
            new Document("$cond", Arrays.asList(
                new Document("$eq", Arrays.asList("$delta.input.name", "mpsid")), 
                "$delta.input.value", null)))),
        
        new Document("lineValues", new Document("$push", 
            new Document("$cond", Arrays.asList(
                new Document("$in", Arrays.asList("$delta.input.name", groupingAttributes)),
                new Document("$split", Arrays.asList("$delta.input.value", ";")),
                Arrays.asList())))))
    ),
    
    // Project to get the union of line1 and line2 values, ensuring unique values
    Aggregates.project(new Document("cdsid", "$_id.cdsid")
        .append("mpsid", "$_id.mpsid")
        .append("lineValues", new Document("$reduce", new Document("input", "$lineValues")
            .append("initialValue", Arrays.asList())
            .append("in", new Document("$setUnion", Arrays.asList("$$value", "$$this")))))),

    // Match only those records where the number of distinct lineValues > 3
    Aggregates.match(Filters.expr(new Document("$gt", Arrays.asList(
        new Document("$size", "$lineValues"), 3))))
);

// Execute the aggregation query
AggregateIterable<Document> result = collection1.aggregate(pipeline);

// Iterate over the result and process documents
for (Document doc : result) {
    System.out.println(doc.toJson());
}
