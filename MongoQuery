List<Bson> aggregationPipeline = Arrays.asList(
    // Match documents from Collection 1 based on mapDefId, masterId, and presence of delta.input
    Aggregates.match(Filters.and(
        Filters.eq("mapDefId", mapDefId), // Use the mapDefId for filtering
        Filters.eq("masterId", masterId), // Use the masterId for filtering
        Filters.exists("delta.input") // Ensure delta.input is present
    )),
    
    // Add fields for selection attributes using $filter operator based on the provided selectionAttributes
    Aggregates.addFields(
        new Field<>("selectionAttributes", 
            new Document("$filter", 
                new Document("input", "$delta.input")
                    .append("as", "item")
                    .append("cond", new Document("$in", Arrays.asList(
                        "$$item.name", selectionAttributes)) // Dynamically match based on selectionAttributes
                    )
                )
            )
        )
    ),
    
    // Project to include necessary fields
    Aggregates.project(Projections.fields(
        Projections.include("seq", "mapDefId", "masterId", "selectionAttributes", "snapshot.input", "delta.input")
    )),
    
    // Lookup documents from Collection 2 based on seq field
    Aggregates.lookup("collection2", "seq", "seq", "joined_docs"),
    
    // Unwind the joined documents from Collection 2 with preserveNullAndEmptyArrays option
    Aggregates.unwind("$joined_docs", new UnwindOptions().preserveNullAndEmptyArrays(true)),
    
    // Group by selection attributes and collect distinct grouping attribute values
    Aggregates.group("_id", 
        Accumulators.addToSet("selectionAttributes", "$selectionAttributes"),
        Accumulators.addToSet("groupingAttributesValues", "$joined_docs.input")
    ),
    
    // Match where groupingAttributesValues have more than 3 distinct values
    Aggregates.match(Filters.gt(new Document("$size", "$groupingAttributesValues"), 3)) // Size condition corrected
);
