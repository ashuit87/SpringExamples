import com.mongodb.client.model.*;
import org.bson.Document;
import org.bson.conversions.Bson;

import java.util.*;
import java.util.stream.Collectors;

public class MongoAggregation {
    public static void main(String[] args) {
        // Provided dynamic values
        String mapDefId = "99";  
        String masterId = "12";  
        List<String> selectionAttributes = Arrays.asList("cdsid", "mpsid");  
        List<String> groupingAttributes = Arrays.asList("line1", "line2");  

        // Step 1: Match documents based on mapDefId and masterId in Collection 1
        Bson matchStage = Aggregates.match(Filters.and(
            Filters.eq("mapDefId", mapDefId),
            Filters.eq("masterId", masterId)
        ));

        // Step 2: Unwind delta.input and snapshot.input to flatten attributes
        Bson unwindDelta = Aggregates.unwind("$delta.input", true);
        Bson unwindSnapshot = Aggregates.unwind("$snapshot.input", true);

      List<Bson> selectionFieldUpdates = selectionAttributes.stream()
            .map(attr -> {
                // Creating Bson Update for each attribute
                return Updates.set(attr, new Document("$ifNull", Arrays.asList(
                    // Try to get the value from delta.input (if present)
                    new Document("$arrayElemAt", Arrays.asList(
                        new Document("$filter", new Document()
                            .append("input", "$delta.input") // Delta input array
                            .append("as", "item")
                            .append("cond", new Document("$eq", Arrays.asList("$$item.name", attr))) // Match name
                        )),
                        0  // Take the first element from the filtered result
                    )),
                    // If not found in delta, look for it in snapshot.input
                    new Document("$arrayElemAt", Arrays.asList(
                        new Document("$filter", new Document()
                            .append("input", "$snapshot.input") // Snapshot input array
                            .append("as", "item")
                            .append("cond", new Document("$eq", Arrays.asList("$$item.name", attr))) // Match name
                        )),
                        0  // Take the first element from the filtered result
                    ))
                )));  // End of Updates.set
            })
            .collect(Collectors.toList());  /


        Bson addSelectionFields = Aggregates.addFields(selectionFieldUpdates);

        // Step 4: Lookup Collection 2 using seq and mapDefId
        Bson lookupStage = Aggregates.lookup(
            "collection2",
            Arrays.asList(
                new Document("seq", "$delta.seq"),
                new Document("mapDefId", "$mapDefId")
            ),
            Arrays.asList("seq", "mapDefId"),
            "joined_docs"
        );

        // Step 5: Handle missing lookup results (if empty, fallback to Collection 1 only)
        Bson setFallback = Aggregates.addFields(
            new Field<>("joined_docs", new Document("$ifNull", Arrays.asList("$joined_docs", Collections.emptyList())))
        );

        // Step 6: Unwind joined_docs, keeping null values (optional)
        Bson unwindJoinedDocs = Aggregates.unwind("$joined_docs", true);

        // Step 7: Use $match to check if lookup was successful
        Bson matchLookupSuccess = Aggregates.match(new Document("$or", Arrays.asList(
            new Document("joined_docs", new Document("$ne", Collections.emptyList())),  // Lookup succeeded
            new Document("joined_docs", new Document("$exists", false))  // Fallback to Collection 1
        )));

        // Step 8: Group by dynamically provided grouping attributes
        Document groupFields = new Document();
        for (String attr : groupingAttributes) {
            groupFields.append(attr, "$" + attr);
        }

        Bson groupStage = Aggregates.group(
            groupFields,
            Accumulators.addToSet("groupingAttributesValues", "$$ROOT")
        );

        // Step 9: Filter groups where the size of distinct line values > 3
        Bson matchSizeFilter = Aggregates.match(Filters.expr(new Document("$gt", Arrays.asList(
            new Document("$size", "$groupingAttributesValues"), 3
        ))));

        // Step 10: Build pipeline
        List<Bson> aggregationPipeline = Arrays.asList(
            matchStage,
            unwindDelta,
            unwindSnapshot,
            addSelectionFields,
            lookupStage,
            setFallback,        // Ensure joined_docs is not null
            unwindJoinedDocs,
            matchLookupSuccess, // If lookup fails, use Collection 1 only
            groupStage,
            matchSizeFilter
        );

        // The aggregationPipeline can be executed using MongoDB client
        System.out.println(aggregationPipeline);
    }
}
