List<Bson> aggregationPipeline = Arrays.asList(
    // Match documents from Collection 1 based on mapDefId, masterId, and presence of delta.input
    Aggregates.match(Filters.and(
        Filters.eq("mapDefId", mapDefId), // Use mapDefId for filtering in Collection 1
        Filters.eq("masterId", masterId), // Use masterId for filtering
        Filters.exists("delta.input") // Ensure delta.input is present
    )),
    
    // Add fields for selection attributes using $filter operator based on the provided selectionAttributes
    Aggregates.addFields(
        new Field<>("selectionAttributes", 
            new Document("$filter", 
                new Document("input", "$delta.input")
                    .append("as", "item")
                    .append("cond", new Document("$in", Arrays.asList(
                        "$$item.name", selectionAttributes)) // Dynamically match based on selectionAttributes
                    )
                )
            )
        )
    ),
    
    // Project to include necessary fields
    Aggregates.project(Projections.fields(
        Projections.include("seq", "mapDefId", "masterId", "selectionAttributes", "snapshot.input", "delta.input")
    )),
    
    // Lookup documents from Collection 2 based on both seq and mapDefId
    Aggregates.lookup(
        "collection2", 
        Arrays.asList(
            new Document("seq", "$seq"), // Match seq field in Collection 1 to seq field in Collection 2
            new Document("mapDefId", "$mapDefId") // Match mapDefId field in Collection 1 to mapDefId field in Collection 2
        ),
        Arrays.asList("seq", "mapDefId"), // Foreign fields in Collection 2 to match
        "joined_docs" // Name of the resulting array field in the output
    ),
    
    // Unwind the joined documents from Collection 2
    Aggregates.unwind("$joined_docs", new UnwindOptions().preserveNullAndEmptyArrays(true)),
    
    // Group by selection attributes and collect distinct grouping attribute values
    Aggregates.group("_id", 
        Accumulators.addToSet("selectionAttributes", "$selectionAttributes"),
        Accumulators.addToSet("groupingAttributesValues", "$joined_docs.input")
    ),
    
    // Match where groupingAttributesValues have more than 3 distinct values
    Aggregates.match(Filters.expr(
        new Document("$gt", Arrays.asList(
            new Document("$size", "$groupingAttributesValues"), 3
        ))
    ))
);
