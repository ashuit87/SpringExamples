import com.mongodb.client.*;
import com.mongodb.client.model.*;
import org.bson.Document;
import org.bson.conversions.Bson;
import java.util.*;

public class MongoAggregation {
    public static void main(String[] args) {
        // MongoDB Connection
        MongoClient mongoClient = MongoClients.create("mongodb://localhost:27017");
        MongoDatabase database = mongoClient.getDatabase("yourDatabase");

        // Collection References
        MongoCollection<Document> collection1 = database.getCollection("collection1");
        MongoCollection<Document> collection2 = database.getCollection("collection2");

        // Define dynamic selection & grouping attributes
        List<String> selectionAttributes = Arrays.asList("cdsid", "mpsid");
        List<String> groupingAttributes = Arrays.asList("line1", "line2");

        // Step 1: Unwind delta and snapshot inputs
        List<Bson> pipeline = Arrays.asList(
            Aggregates.unwind("$snapshot.input", true),
            Aggregates.unwind("$delta.input", true),

            // Step 2: Extract key-value pairs from delta and snapshot
            Aggregates.group(
                "$_id",
                new Document("seq", new Document("$first", "$seq"))
                        .append("mapDefId", new Document("$first", "$mapDefId"))
                        .append("selectionAttributes", new Document("$push", new Document("k", "$delta.input.name").append("v", "$delta.input.value")))
                        .append("snapshotSelection", new Document("$push", new Document("k", "$snapshot.input.name").append("v", "$snapshot.input.value")))
                        .append("groupingAttributes", new Document("$push", new Document("k", "$delta.input.name").append("v", "$delta.input.value")))
                        .append("snapshotGrouping", new Document("$push", new Document("k", "$snapshot.input.name").append("v", "$snapshot.input.value")))
            ),

            // Step 3: Merge delta and snapshot values
            Aggregates.addFields(new Document("finalSelectionAttributes",
                new Document("$concatArrays", Arrays.asList(
                    "$selectionAttributes",
                    new Document("$filter",
                        new Document("input", "$snapshotSelection")
                                .append("as", "attr")
                                .append("cond", new Document("$not", new Document("$in", Arrays.asList("$$attr.k", "$selectionAttributes.k"))))
                    )
                ))
            )),
            Aggregates.addFields(new Document("finalGroupingAttributes",
                new Document("$concatArrays", Arrays.asList(
                    "$groupingAttributes",
                    new Document("$filter",
                        new Document("input", "$snapshotGrouping")
                                .append("as", "attr")
                                .append("cond", new Document("$not", new Document("$in", Arrays.asList("$$attr.k", "$groupingAttributes.k"))))
                    )
                ))
            )),

            // Step 4: Extract unique grouping attribute values
            Aggregates.addFields(new Document("groupAttributeValues",
                new Document("$reduce", new Document("input", "$finalGroupingAttributes.v")
                        .append("initialValue", Arrays.asList())
                        .append("in", new Document("$setUnion", Arrays.asList("$$value", new Document("$split", Arrays.asList("$$this", ";"))))))
            )),

            // Step 5: Filter only records where grouping attribute values exceed 3
            Aggregates.match(Filters.expr(new Document("$gt", Arrays.asList(new Document("$size", "$groupAttributeValues"), 3)))),

            // Step 6: Lookup matching documents in Collection 2 using seq
            Aggregates.lookup("collection2", "seq", "seq", "joined_docs"),

            // Step 7: Filter by mapDefId (if needed)
            Aggregates.match(Filters.eq("mapDefId", "99")),  // Can be parameterized

            // Step 8: Final projection
            Aggregates.project(Projections.fields(
                Projections.excludeId(),
                Projections.include("seq", "mapDefId", "finalSelectionAttributes", "finalGroupingAttributes", "groupAttributeValues", "joined_docs")
            ))
        );

        // Execute Query
        collection1.aggregate(pipeline).forEach(doc -> System.out.println(doc.toJson()));

        // Close MongoDB Connection
        mongoClient.close();
    }
}
