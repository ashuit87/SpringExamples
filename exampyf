const BATCH_SIZE = 500;

const sourceMasterCollection = db.getCollection("dbsync_queue");
const sourceDataCollection = db.getCollection("rule_inst_change");
const targetDataCollection = db.getCollection("rule_inst_change_history");
const auditProcessCollection = db.getCollection("automation_log_cleanup_queue");

let lastId = null;

while (true) {
  // Step 1: Fetch batch of masterRequestIds with status "COMPLETED"
  const query = lastId
    ? { status: "COMPLETED", _id: { $gt: lastId } }
    : { status: "COMPLETED" };

  const masterIdBatch = await sourceMasterCollection
    .find(query)
    .sort({ _id: 1 })
    .limit(BATCH_SIZE)
    .project({ masterRequestId: 1 })
    .toArray();

  if (!masterIdBatch || masterIdBatch.length === 0) {
    print("All batches processed.");
    break;
  }

  const masterRequestIds = masterIdBatch.map(doc => doc.masterRequestId).filter(Boolean);
  lastId = masterIdBatch[masterIdBatch.length - 1]._id;

  print(`Processing batch of ${masterRequestIds.length} masterRequestIds`);
  console.log("Batch masterRequestIds:", masterRequestIds);

  if (masterRequestIds.length === 0) continue;

  // Step 2: Fetch documents from sourceDataCollection with matching masterId
  const docsToMove = await sourceDataCollection
    .find({ masterId: { $in: masterRequestIds } })
    .toArray();

  if (!docsToMove || docsToMove.length === 0) {
    print("No matching documents found in rule_inst_change.");
    continue;
  }

  const idsToInsert = docsToMove.map(doc => doc._id);

  // Step 3: Insert to targetDataCollection, skip duplicates
  const bulkInsertOps = docsToMove.map(doc => ({
    replaceOne: {
      filter: { _id: doc._id },
      replacement: doc,
      upsert: true,
    },
  }));

  const insertResult = await targetDataCollection.bulkWrite(bulkInsertOps, { ordered: false });
  print(`Inserted or upserted ${insertResult.upsertedCount + insertResult.modifiedCount} documents into rule_inst_change_history`);
  console.log("Inserted/upserted _ids:", idsToInsert);

  // Step 4: Delete from sourceDataCollection only if present in history
  const historyDocs = await targetDataCollection
    .find({ _id: { $in: idsToInsert } }, { projection: { _id: 1 } })
    .toArray();

  const historyIdSet = new Set(historyDocs.map(doc => doc._id.valueOf()));

  const idsToDelete = docsToMove
    .map(doc => doc._id)
    .filter(id => historyIdSet.has(id.valueOf()));

  if (idsToDelete.length > 0) {
    const deleteResult = await sourceDataCollection.deleteMany({ _id: { $in: idsToDelete } });
    print(`Deleted ${deleteResult.deletedCount} documents from rule_inst_change`);
    console.log("Deleted _ids:", idsToDelete);
  } else {
    print("No matching documents found in history to delete from rule_inst_change.");
  }

  // Step 5: Update auditProcessCollection status to "COMPLETED"
  const updateAuditResult = await auditProcessCollection.updateMany(
    { masterRequestId: { $in: masterRequestIds } },
    { $set: { status: "COMPLETED" } }
  );
  print(`Updated ${updateAuditResult.modifiedCount} documents in auditProcessCollection.`);
}
