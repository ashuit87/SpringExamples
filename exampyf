const sourceDataCollection = db.getCollection("rule_inst_change");
const targetDataCollection = db.getCollection("rule_inst_change_history");

const BATCH_SIZE = 1000;
let lastId = null;
let totalDeleted = 0;

while (true) {
  const query = lastId ? { _id: { $gt: lastId } } : {};
  const batch = sourceDataCollection
    .find(query)
    .sort({ _id: 1 })
    .limit(BATCH_SIZE)
    .toArray();

  if (!batch || batch.length === 0) {
    print("Deletion check completed.");
    break;
  }

  const sourceIds = batch.map(doc => doc._id);
  lastId = batch[batch.length - 1]._id;

  // Find matching documents in the history collection
  const historyIdsSet = new Set(
    targetDataCollection
      .find({ _id: { $in: sourceIds } })
      .map(doc => doc._id.valueOf())
  );

  // Prepare delete operations only for those present in history
  const deleteOps = batch
    .filter(doc => historyIdsSet.has(doc._id.valueOf()))
    .map(doc => ({
      deleteOne: {
        filter: { _id: doc._id }
      }
    }));

  if (deleteOps.length > 0) {
    const result = sourceDataCollection.bulkWrite(deleteOps);
    totalDeleted += result.deletedCount;
    print("Deleted", result.deletedCount, "documents in this batch.");
  } else {
    print("No deletions required in this batch.");
  }
}

print("Total documents deleted from rule_inst_change:", totalDeleted);
