const BATCH_SIZE = 500;

const sourceMasterCollection = db.getCollection("dbsync_queue");
const sourceDataCollection = db.getCollection("rule_inst_change");
const targetDataCollection = db.getCollection("rule_inst_change_history");
const auditProcessCollection = db.getCollection("automation_log_cleanup_queue");

let lastId = null;

function processBatch() {
  const query = lastId
    ? { status: "COMPLETED", _id: { $gt: lastId } }
    : { status: "COMPLETED" };

  sourceMasterCollection.find(query)
    .sort({ _id: 1 })
    .limit(BATCH_SIZE)
    .projection({ masterRequestId: 1 })  // <- replaced `.project(...)` with `.projection(...)`
    .toArray()
    .then(masterIdBatch => {
      if (!masterIdBatch || masterIdBatch.length === 0) {
        print("All batches processed.");
        return;
      }

      const masterRequestIds = masterIdBatch.map(doc => doc.masterRequestId).filter(Boolean);
      lastId = masterIdBatch[masterIdBatch.length - 1]._id;

      print("Processing batch of masterRequestIds:");
      print(masterRequestIds);

      if (masterRequestIds.length === 0) {
        processBatch();
        return;
      }

      sourceDataCollection.find({ masterId: { $in: masterRequestIds } }).toArray()
        .then(docsToMove => {
          if (!docsToMove || docsToMove.length === 0) {
            print("No matching documents found in rule_inst_change.");
            processBatch();
            return;
          }

          const idsToInsert = docsToMove.map(doc => doc._id);
          const bulkInsertOps = docsToMove.map(doc => ({
            replaceOne: {
              filter: { _id: doc._id },
              replacement: doc,
              upsert: true
            }
          }));

          targetDataCollection.bulkWrite(bulkInsertOps, { ordered: false })
            .then(insertResult => {
              print(`Inserted or upserted ${insertResult.upsertedCount + insertResult.modifiedCount} documents`);
              print("Inserted/upserted _ids:");
              print(idsToInsert);

              targetDataCollection.find({ _id: { $in: idsToInsert } }, { projection: { _id: 1 } })
                .toArray()
                .then(historyDocs => {
                  const historyIdSet = new Set(historyDocs.map(doc => doc._id.valueOf()));
                  const idsToDelete = docsToMove
                    .map(doc => doc._id)
                    .filter(id => historyIdSet.has(id.valueOf()));

                  if (idsToDelete.length > 0) {
                    sourceDataCollection.deleteMany({ _id: { $in: idsToDelete } })
                      .then(deleteResult => {
                        print(`Deleted ${deleteResult.deletedCount} documents from rule_inst_change`);
                        print("Deleted _ids:");
                        print(idsToDelete);

                        auditProcessCollection.updateMany(
                          { masterRequestId: { $in: masterRequestIds } },
                          { $set: { status: "COMPLETED" } }
                        ).then(updateResult => {
                          print(`Updated ${updateResult.modifiedCount} auditProcess records`);
                          processBatch();
                        });
                      });
                  } else {
                    print("No matching documents found in history to delete.");
                    processBatch();
                  }
                });
            });
        });
    });
}

// Start the process
processBatch();
